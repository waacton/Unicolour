namespace Wacton.Unicolour;

using System;

public class Rgb : IEquatable<Rgb>
{
    public double R { get; }
    public double G { get; }
    public double B { get; }

    public int R255 => (int) Math.Round(R * 255);
    public int G255 => (int) Math.Round(G * 255);
    public int B255 => (int) Math.Round(B * 255);
    public string Hex => $"#{R255:X2}{G255:X2}{B255:X2}";

    public double RLinear => LinearCorrection(R);
    public double GLinear => LinearCorrection(G);
    public double BLinear => LinearCorrection(B);

    public Rgb(double r, double g, double b)
    {
        r.Guard(0.0, 1.0, "Red");
        g.Guard(0.0, 1.0, "Green");
        b.Guard(0.0, 1.0, "Blue");

        R = r;
        G = g;
        B = b;
    }

    // https://en.wikipedia.org/wiki/SRGB#From_sRGB_to_CIE_XYZ
    public static double LinearCorrection(double value)
    {
        return value <= 0.04045 
            ? value / 12.92 
            : Math.Pow((value + 0.055) / 1.055, 2.4);
    }

    public override string ToString() => $"{R255} {G255} {B255} {Hex}";

    // --- autogenerated ---
    
    public bool Equals(Rgb? other)
    {
        if (ReferenceEquals(null, other)) return false;
        if (ReferenceEquals(this, other)) return true;
        return R.Equals(other.R) && G.Equals(other.G) && B.Equals(other.B);
    }

    public override bool Equals(object? obj)
    {
        if (ReferenceEquals(null, obj)) return false;
        if (ReferenceEquals(this, obj)) return true;
        if (obj.GetType() != this.GetType()) return false;
        return Equals((Rgb) obj);
    }

    public override int GetHashCode()
    {
        unchecked
        {
            var hashCode = R.GetHashCode();
            hashCode = (hashCode * 397) ^ G.GetHashCode();
            hashCode = (hashCode * 397) ^ B.GetHashCode();
            return hashCode;
        }
    }
}